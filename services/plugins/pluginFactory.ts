import * as fs from 'fs/promises';
import * as path from 'path';
import { IPlugin } from './pluginInterface';

export interface PluginCreationRequest {
    name: string;        // Human readable name: "Google Calendar"
    id: string;          // Kebab case: "google-calendar"
    category: string;    // "integrations", "core", "media"
    description: string;
    tools: string[];     // List of tool names to scaffold
}

/**
 * PLUGIN FACTORY
 * 
 * Automates the creation of new Plugins to ensure they adhere to the standard.
 * - Creates directory structure
 * - Generates index.ts (Manifest)
 * - Generates tools.ts (Stubs)
 * - Generates README.md
 */
export class PluginFactory {

    private getPluginPath(category: string, id: string): string {
        return path.join(process.cwd(), 'services', 'plugins', category, id);
    }

    /**
     * Scaffolds a new Plugin on disk.
     */
    public async createPlugin(request: PluginCreationRequest): Promise<{ success: boolean; path: string; error?: string }> {
        const pluginDir = this.getPluginPath(request.category, request.id);

        try {
            // 1. Check if exists
            try {
                await fs.access(pluginDir);
                return { success: false, path: pluginDir, error: "Plugin directory already exists." };
            } catch {
                // Good, doesn't exist
            }

            // 2. Create Directory
            await fs.mkdir(pluginDir, { recursive: true });

            // 3. Generate tools.ts
            await fs.writeFile(path.join(pluginDir, 'tools.ts'), this.generateToolsTemplate(request.tools));

            // 4. Generate index.ts
            await fs.writeFile(path.join(pluginDir, 'index.ts'), this.generateIndexTemplate(request));

            // 5. Generate README.md (Documentation)
            await fs.writeFile(path.join(pluginDir, 'README.md'), this.generateReadmeTemplate(request));

            return { success: true, path: pluginDir };

        } catch (error: any) {
            return { success: false, path: pluginDir, error: error.message };
        }
    }

    private generateToolsTemplate(toolNames: string[]): string {
        return `// Tool Implementations
// Auto-generated by PluginFactory

${toolNames.map(name => `
export const handle${this.toPascalCase(name)} = async (args: any) => {
    try {
        console.log('[${name}] Executing with:', args);
        // TODO: Implement logic
        return { status: 'success', message: 'Tool executed stub.' };
    } catch (error: any) {
        throw new Error(\`Failed to execute ${name}: \${error.message}\`);
    }
};
`).join('\n')}
`;
    }

    private generateIndexTemplate(req: PluginCreationRequest): string {
        return `import { IPlugin } from '../../pluginInterface';
import * as tools from './tools';

const plugin: IPlugin = {
    id: '${req.id}',
    name: '${req.name}',
    version: '1.0.0',
    description: '${req.description}',
    author: 'Silhouette User',
    
    tools: [
        ${req.tools.map(t => `{
            name: '${t}',
            description: 'Auto-generated description for ${t}',
            category: 'UTILITY',
            parameters: {
                type: 'OBJECT',
                properties: {
                    // TODO: Define parameters
                    param1: { type: 'STRING', description: 'Parameter description' }
                },
                required: ['param1']
            },
            handler: tools.handle${this.toPascalCase(t)}
        }`).join(',\n        ')}
    ],
    
    onInit: async () => {
        console.log('[Plugin:${req.id}] Initializing...');
        // TODO: Add initialization logic (e.g. check env vars)
    }
};

export default plugin;
`;
    }

    private generateReadmeTemplate(req: PluginCreationRequest): string {
        return `# ${req.name} Plugin

${req.description}

## Tools
${req.tools.map(t => `- **${t}**: Auto-generated description`).join('\n')}

## Setup
1. Check \`index.ts\` and define parameter schemas.
2. Implement logic in \`tools.ts\`.
3. Register in environment if needed.
`;
    }

    private toPascalCase(str: string): string {
        return str.replace(/(^\w|_\w)/g, m => m.replace('_', '').toUpperCase());
    }
}

export const pluginFactory = new PluginFactory();
